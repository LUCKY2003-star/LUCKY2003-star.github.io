<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Luxury Interactive Christmas Tree</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@19.0.0-rc.0/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@19.0.0-rc.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@react-three/fiber@8.15.12/dist/umd/index.min.js"></script>
    <script src="https://unpkg.com/@react-three/drei@9.88.14/dist/umd/index.min.js"></script>
    <script src="https://unpkg.com/@react-three/postprocessing@2.15.11/dist/umd/index.min.js"></script>
    <script src="https://unpkg.com/leapjs@1.1.1/leap.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils@0.3.1646425220/camera_utils.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils@0.3.1646425220/drawing_utils.min.js"></script>
    <script src="https://unpkg.com/typescript@5.3.3/lib/typescript.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        emerald: {
                            deep: '#004d40',
                            lux: '#00695c'
                        },
                        gold: {
                            highlight: '#ffd700',
                            dark: '#b8860b'
                        }
                    },
                    fontFamily: {
                        luxury: ['Garamond', 'serif']
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .glow {
                filter: drop-shadow(0 0 8px theme('colors.gold.highlight'));
            }
            .tree-shadow {
                box-shadow: 0 0 20px theme('colors.emerald.deep');
            }
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at bottom, #0a1015 0%, #000 100%);
        }
        
        canvas {
            display: block;
        }
        
        .polaroid {
            position: absolute;
            background: white;
            padding: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transform-origin: center;
            border: 1px solid #ddd;
        }
        
        .polaroid img {
            width: 100%;
            height: auto;
            display: block;
        }
        
        .polaroid-caption {
            text-align: center;
            padding: 8px 0;
            font-family: 'Comic Sans MS', cursive;
            font-size: 12px;
        }
        
        #gesture-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: #ffd700;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #b8860b;
            font-family: 'Garamond', serif;
            z-index: 100;
        }
        
        #camera-feed {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border: 3px solid #ffd700;
            border-radius: 8px;
            overflow: hidden;
            z-index: 99;
        }
    </style>
</head>
<body>
    <div id="root" class="w-full h-screen"></div>
    <div id="gesture-overlay">
        <h3 class="text-xl mb-2">üéÑ Gesture Control</h3>
        <p>Open hand: Unleash Chaos</p>
        <p>Closed hand: Form Tree</p>
        <p>Move hand: Adjust View</p>
        <div id="gesture-status" class="mt-4 text-gold-highlight">Status: Detecting...</div>
    </div>
    <div id="camera-feed"></div>

    <script type="text/babel" data-type="module">
        // TypeScriptÁ±ªÂûãÂÆö‰πâ
        const { useState, useRef, useEffect, useMemo } = React;
        const { Canvas, useFrame, useThree, extend } = ReactThreeFiber;
        const { OrbitControls, Environment, InstancedMesh, Points, PointMaterial, useGLTF, useTexture } = ReactThreeDrei;
        const { EffectComposer, Bloom, Noise, Vignette } = ReactThreePostprocessing;

        // Áä∂ÊÄÅÁ±ªÂûãÂÆö‰πâ
        const TreeState = {
            CHAOS: 'CHAOS',
            FORMED: 'FORMED'
        };

        // ÂùêÊ†áÊé•Âè£
        class Vector3 extends THREE.Vector3 {}
        class Color extends THREE.Color {}

        // ‰∏ªÂ∫îÁî®ÁªÑ‰ª∂
        const App = () => {
            const [treeState, setTreeState] = useState(TreeState.FORMED);
            const [progress, setProgress] = useState(0);
            const [handPosition, setHandPosition] = useState({ x: 0, y: 0 });
            const cameraRef = useRef(null);
            const { camera } = useThree();
            
            // ÂàùÂßãÂåñÊëÑÂÉèÊú∫‰ΩçÁΩÆ
            useEffect(() => {
                camera.position.set(0, 4, 20);
                cameraRef.current = camera;
            }, [camera]);

            // ÊâãÂäøÊéßÂà∂ÈÄªËæë
            useEffect(() => {
                const videoElement = document.createElement('video');
                document.getElementById('camera-feed').appendChild(videoElement);
                
                const hands = new window.mediapipe.hands.Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
                });

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.7
                });

                hands.onResults((results) => {
                    const statusElement = document.getElementById('gesture-status');
                    
                    if (results.multiHandLandmarks) {
                        const hand = results.multiHandLandmarks[0];
                        const handType = results.multiHandedness[0].label;
                        
                        // ËÆ°ÁÆóÊâãÊåáÂº†ÂºÄÁ®ãÂ∫¶
                        const thumbTip = hand[4];
                        const indexTip = hand[8];
                        const middleTip = hand[12];
                        const ringTip = hand[16];
                        const pinkyTip = hand[20];
                        const palm = hand[0];
                        
                        // ËÆ°ÁÆóÊâãÊéå‰∏≠ÂøÉ
                        const palmX = (thumbTip.x + indexTip.x + middleTip.x + ringTip.x + pinkyTip.x) / 5;
                        const palmY = (thumbTip.y + indexTip.y + middleTip.y + ringTip.y + pinkyTip.y) / 5;
                        
                        // Êõ¥Êñ∞ÊâãÈÉ®‰ΩçÁΩÆÁî®‰∫éËßÜËßíÊéßÂà∂
                        setHandPosition({
                            x: (palmX - 0.5) * -10,
                            y: (palmY - 0.5) * 10
                        });
                        
                        // ËÆ°ÁÆóÊâãÊåáÂº†ÂºÄÂ∫¶
                        const thumbDistance = Math.hypot(thumbTip.x - palm.x, thumbTip.y - palm.y);
                        const indexDistance = Math.hypot(indexTip.x - palm.x, indexTip.y - palm.y);
                        const middleDistance = Math.hypot(middleTip.x - palm.x, middleTip.y - palm.y);
                        const ringDistance = Math.hypot(ringTip.x - palm.x, ringTip.y - palm.y);
                        const pinkyDistance = Math.hypot(pinkyTip.x - palm.x, pinkyTip.y - palm.y);
                        
                        const avgDistance = (thumbDistance + indexDistance + middleDistance + ringDistance + pinkyDistance) / 5;
                        
                        // Âà§Êñ≠Áä∂ÊÄÅ
                        if (avgDistance > 0.15) {
                            setTreeState(TreeState.CHAOS);
                            setProgress(Math.min(1, progress + 0.02));
                            statusElement.textContent = 'Status: Chaos Mode (Unleashed)';
                        } else {
                            setTreeState(TreeState.FORMED);
                            setProgress(Math.max(0, progress - 0.02));
                            statusElement.textContent = 'Status: Formed Mode (Tree)';
                        }
                    } else {
                        statusElement.textContent = 'Status: No hand detected';
                    }
                });

                const cameraUtils = new window.mediapipe.camera_utils.Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: 200,
                    height: 150
                });

                cameraUtils.start();

                return () => {
                    cameraUtils.stop();
                    hands.close();
                };
            }, [progress]);

            // ËßÜËßíÊéßÂà∂
            useFrame((state) => {
                if (cameraRef.current) {
                    // Ê†πÊçÆÊâãÈÉ®‰ΩçÁΩÆË∞ÉÊï¥ÊëÑÂÉèÊú∫
                    cameraRef.current.position.x += (handPosition.x - cameraRef.current.position.x) * 0.05;
                    cameraRef.current.position.y += (4 + handPosition.y - cameraRef.current.position.y) * 0.05;
                    cameraRef.current.lookAt(0, 2, 0);
                }
            });

            return (
                <Canvas shadows dpr={[1, 2]}>
                    <color attach="background" args={['#000814']} />
                    <fog attach="fog" args={['#001a1a', 10, 50]} />
                    
                    {/* ÁéØÂ¢ÉÂÖâÂíåHDRI */}
                    <Environment preset="lobby" />
                    <ambientLight intensity={0.3} color="#004d40" />
                    <directionalLight 
                        position={[10, 10, 5]} 
                        intensity={1.2} 
                        color="#ffd700"
                        castShadow
                    />
                    
                    {/* Âú£ËØûÊ†ëÊ†∏ÂøÉÁªÑ‰ª∂ */}
                    <ChristmasTree progress={progress} />
                    
                    {/* ÂêéÊúüÂ§ÑÁêÜ */}
                    <EffectComposer>
                        <Bloom 
                            luminanceThreshold={0.8}
                            luminanceSmoothing={0.05}
                            intensity={1.2}
                            radius={0.5}
                        />
                        <Noise opacity={0.02} />
                        <Vignette eskil={false} offset={0.1} darkness={0.4} />
                    </EffectComposer>
                    
                    {/* ÊéßÂà∂Âô®ÔºàÂ§áÁî®Ôºâ */}
                    <OrbitControls 
                        enablePan={false}
                        enableZoom={true}
                        maxPolarAngle={Math.PI / 2}
                        minDistance={10}
                        maxDistance={30}
                    />
                </Canvas>
            );
        };

        // Âú£ËØûÊ†ëÊ†∏ÂøÉÁªÑ‰ª∂
        const ChristmasTree = ({ progress }) => {
            const foliageRef = useRef(null);
            const ornamentsRef = useRef(null);
            const polaroidsRef = useRef(null);
            
            // ÈÖçÁΩÆÂèÇÊï∞
            const FOLIAGE_COUNT = 50000;
            const ORNAMENT_COUNT = 500;
            const POLAROID_COUNT = 30;
            
            // ÁîüÊàêÈöèÊú∫ÂùêÊ†á
            const generateChaosPosition = () => {
                return new Vector3(
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 40
                );
            };
            
            // ÁîüÊàêÊ†ëÂΩ¢ÁõÆÊ†áÂùêÊ†áÔºàÂúÜÈî•‰ΩìÔºâ
            const generateTargetPosition = (index) => {
                const layer = Math.floor(index / (FOLIAGE_COUNT / 10));
                const radius = 8 - (layer * 0.8);
                const height = layer * 0.8;
                
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * radius;
                
                return new Vector3(
                    Math.cos(angle) * r,
                    height - 5,
                    Math.sin(angle) * r
                );
            };
            
            // ÂàùÂßãÂåñÈíàÂè∂Á≤íÂ≠êÊï∞ÊçÆ
            const foliageData = useMemo(() => {
                const positions = [];
                const chaosPositions = [];
                const targetPositions = [];
                const colors = [];
                
                for (let i = 0; i < FOLIAGE_COUNT; i++) {
                    const chaosPos = generateChaosPosition();
                    const targetPos = generateTargetPosition(i);
                    
                    chaosPositions.push(chaosPos.x, chaosPos.y, chaosPos.z);
                    targetPositions.push(targetPos.x, targetPos.y, targetPos.z);
                    
                    // Á•ñÊØçÁªøÊ∏êÂèò
                    const greenShade = new Color(0x00695c);
                    greenShade.offsetHSL(0, 0, Math.random() * 0.2 - 0.1);
                    colors.push(greenShade.r, greenShade.g, greenShade.b);
                    
                    // ÂàùÂßã‰ΩçÁΩÆ
                    positions.push(targetPos.x, targetPos.y, targetPos.z);
                }
                
                return {
                    positions: new Float32Array(positions),
                    chaosPositions: new Float32Array(chaosPositions),
                    targetPositions: new Float32Array(targetPositions),
                    colors: new Float32Array(colors)
                };
            }, []);
            
            // ÂàùÂßãÂåñË£ÖÈ•∞Áâ©Êï∞ÊçÆ
            const ornamentData = useMemo(() => {
                const chaosPositions = [];
                const targetPositions = [];
                const types = []; // 0:Á§ºÁâ©Áõí, 1:ÂΩ©ÁêÉ, 2:ÁÅØÂÖâ
                const colors = [];
                
                for (let i = 0; i < ORNAMENT_COUNT; i++) {
                    // ÈöèÊú∫Á±ªÂûã
                    const type = Math.random() > 0.7 ? 0 : (Math.random() > 0.5 ? 1 : 2);
                    types.push(type);
                    
                    // ÂùêÊ†á
                    const chaosPos = generateChaosPosition();
                    const layer = Math.floor(Math.random() * 10);
                    const radius = 7 - (layer * 0.7);
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * radius;
                    
                    const targetPos = new Vector3(
                        Math.cos(angle) * r,
                        layer * 0.8 - 4,
                        Math.sin(angle) * r
                    );
                    
                    chaosPositions.push(chaosPos.x, chaosPos.y, chaosPos.z);
                    targetPositions.push(targetPos.x, targetPos.y, targetPos.z);
                    
                    // È¢úËâ≤ÔºàÈáëËâ≤/Á∫¢Ëâ≤/ÁªøËâ≤Ôºâ
                    let color;
                    if (type === 0) color = new Color(Math.random() > 0.5 ? 0xffd700 : 0xb8860b); // Á§ºÁâ©ÁõíÔºàÈáëËâ≤Ôºâ
                    if (type === 1) color = new Color(Math.random() > 0.5 ? 0xff0000 : 0x00695c); // ÂΩ©ÁêÉÔºàÁ∫¢/ÁªøÔºâ
                    if (type === 2) color = new Color(0xffd700); // ÁÅØÂÖâÔºàÈáëËâ≤Ôºâ
                    
                    colors.push(color.r, color.g, color.b);
                }
                
                return {
                    chaosPositions: new Float32Array(chaosPositions),
                    targetPositions: new Float32Array(targetPositions),
                    types: new Float32Array(types),
                    colors: new Float32Array(colors)
                };
            }, []);
            
            // ÂàùÂßãÂåñÊãçÁ´ãÂæóÁÖßÁâáÊï∞ÊçÆ
            const polaroidData = useMemo(() => {
                const chaosPositions = [];
                const targetPositions = [];
                
                for (let i = 0; i < POLAROID_COUNT; i++) {
                    const chaosPos = generateChaosPosition();
                    
                    // Ê†ëÂΩ¢‰ΩçÁΩÆ
                    const layer = Math.floor(Math.random() * 8) + 1;
                    const radius = 6 - (layer * 0.6);
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * radius;
                    
                    const targetPos = new Vector3(
                        Math.cos(angle) * r,
                        layer * 0.8 - 3,
                        Math.sin(angle) * r
                    );
                    
                    chaosPositions.push(chaosPos.x, chaosPos.y, chaosPos.z);
                    targetPositions.push(targetPos.x, targetPos.y, targetPos.z);
                }
                
                return {
                    chaosPositions: new Float32Array(chaosPositions),
                    targetPositions: new Float32Array(targetPositions)
                };
            }, []);
            
            // Â∏ßÊõ¥Êñ∞ÔºöÊèíÂÄºÂä®Áîª
            useFrame(() => {
                // Êõ¥Êñ∞ÈíàÂè∂Á≤íÂ≠ê
                if (foliageRef.current) {
                    const positions = foliageRef.current.geometry.attributes.position.array;
                    const chaos = foliageData.chaosPositions;
                    const target = foliageData.targetPositions;
                    
                    for (let i = 0; i < FOLIAGE_COUNT * 3; i += 3) {
                        positions[i] = THREE.MathUtils.lerp(target[i], chaos[i], progress);
                        positions[i + 1] = THREE.MathUtils.lerp(target[i + 1], chaos[i + 1], progress);
                        positions[i + 2] = THREE.MathUtils.lerp(target[i + 2], chaos[i + 2], progress);
                    }
                    
                    foliageRef.current.geometry.attributes.position.needsUpdate = true;
                }
                
                // Êõ¥Êñ∞Ë£ÖÈ•∞Áâ©ÂíåÊãçÁ´ãÂæóÔºàÁÆÄÂåñÁâàÔºåÂÆåÊï¥ÂÆûÁé∞ÈúÄÂÆû‰æãÂåñÁΩëÊ†ºÔºâ
            });
            
            // Ëá™ÂÆö‰πâÈíàÂè∂ÁùÄËâ≤Âô®ÊùêË¥®
            const foliageMaterial = useMemo(() => {
                return new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: new Color(0x00695c) },
                        size: { value: 0.15 },
                        progress: { value: progress }
                    },
                    vertexShader: `
                        attribute vec3 color;
                        varying vec3 vColor;
                        uniform float progress;
                        
                        void main() {
                            vColor = color;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = 0.15 * (10.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        uniform float progress;
                        
                        void main() {
                            float distanceToCenter = length(gl_PointCoord - vec2(0.5));
                            if (distanceToCenter > 0.5) discard;
                            
                            gl_FragColor = vec4(vColor * (1.0 - progress * 0.5), 1.0);
                            gl_FragColor.rgb += vec3(0.1, 0.1, 0.0) * (1.0 - distanceToCenter * 2.0);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
            }, [progress]);
            
            // ÂàõÂª∫ÈíàÂè∂Âá†‰Ωï‰Ωì
            const foliageGeometry = useMemo(() => {
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(foliageData.positions, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(foliageData.colors, 3));
                return geo;
            }, [foliageData]);
            
            return (
                <group>
                    {/* ÈíàÂè∂Á≤íÂ≠êÁ≥ªÁªü */}
                    <Points 
                        ref={foliageRef}
                        geometry={foliageGeometry}
                        material={foliageMaterial}
                    />
                    
                    {/* Ê†ëÂπ≤ */}
                    <mesh position={[0, -5, 0]}>
                        <cylinderGeometry args={[1, 1.5, 4, 16]} />
                        <meshStandardMaterial 
                            color="#8B4513"
                            roughness={0.8}
                            metalness={0.2}
                        />
                    </mesh>
                    
                    {/* Ë£ÖÈ•∞Áâ©ÂíåÊãçÁ´ãÂæóÔºàÁÆÄÂåñÂ±ïÁ§∫Ôºâ */}
                    <group ref={ornamentsRef}>
                        {Array.from({ length: 50 }).map((_, i) => {
                            const chaosPos = new Vector3(
                                polaroidData.chaosPositions[i * 3],
                                polaroidData.chaosPositions[i * 3 + 1],
                                polaroidData.chaosPositions[i * 3 + 2]
                            );
                            const targetPos = new Vector3(
                                polaroidData.targetPositions[i * 3],
                                polaroidData.targetPositions[i * 3 + 1],
                                polaroidData.targetPositions[i * 3 + 2]
                            );
                            
                            const pos = new Vector3().lerpVectors(targetPos, chaosPos, progress);
                            
                            // ÊãçÁ´ãÂæóÊ®°Âûã
                            return (
                                <mesh 
                                    key={`polaroid-${i}`}
                                    position={[pos.x, pos.y, pos.z]}
                                    rotation={[0, Math.random() * Math.PI * 2, 0]}
                                >
                                    <boxGeometry args={[0.8, 1, 0.1]} />
                                    <meshStandardMaterial 
                                        color="#ffffff"
                                        roughness={0.9}
                                        metalness={0.1}
                                    />
                                    <mesh position={[0, 0, 0.06]}>
                                        <planeGeometry args={[0.6, 0.6]} />
                                        <meshBasicMaterial 
                                            color={Math.random() > 0.5 ? 0xffd700 : 0x00695c}
                                            transparent
                                            opacity={0.9}
                                        />
                                    </mesh>
                                </mesh>
                            );
                        })}
                        
                        {/* ÈáëËâ≤Ë£ÖÈ•∞ÁêÉ */}
                        {Array.from({ length: 100 }).map((_, i) => {
                            const chaosPos = new Vector3(
                                ornamentData.chaosPositions[i * 3],
                                ornamentData.chaosPositions[i * 3 + 1],
                                ornamentData.chaosPositions[i * 3 + 2]
                            );
                            const targetPos = new Vector3(
                                ornamentData.targetPositions[i * 3],
                                ornamentData.targetPositions[i * 3 + 1],
                                ornamentData.targetPositions[i * 3 + 2]
                            );
                            
                            const pos = new Vector3().lerpVectors(targetPos, chaosPos, progress);
                            
                            return (
                                <mesh 
                                    key={`ornament-${i}`}
                                    position={[pos.x, pos.y, pos.z]}
                                    castShadow
                                    receiveShadow
                                >
                                    <sphereGeometry args={[0.2 + Math.random() * 0.3, 16, 16]} />
                                    <meshStandardMaterial 
                                        color={Math.random() > 0.5 ? 0xffd700 : 0xb8860b}
                                        roughness={0.1}
                                        metalness={0.9}
                                    />
                                </mesh>
                            );
                        })}
                        
                        {/* ÁÅØÂÖâË£ÖÈ•∞ */}
                        {Array.from({ length: 200 }).map((_, i) => {
                            const chaosPos = new Vector3(
                                ornamentData.chaosPositions[(i + 100) * 3],
                                ornamentData.chaosPositions[(i + 100) * 3 + 1],
                                ornamentData.chaosPositions[(i + 100) * 3 + 2]
                            );
                            const targetPos = new Vector3(
                                ornamentData.targetPositions[(i + 100) * 3],
                                ornamentData.targetPositions[(i + 100) * 3 + 1],
                                ornamentData.targetPositions[(i + 100) * 3 + 2]
                            );
                            
                            const pos = new Vector3().lerpVectors(targetPos, chaosPos, progress);
                            
                            return (
                                <pointLight 
                                    key={`light-${i}`}
                                    position={[pos.x, pos.y, pos.z]}
                                    color="#ffd700"
                                    intensity={0.5}
                                    distance={2}
                                    decay={2}
                                />
                            );
                        })}
                    </group>
                    
                    {/* Ê†ëÈ°∂Êòü */}
                    <mesh 
                        position={[0, 3, 0]}
                        scale={1 - progress * 0.8}
                    >
                        <octahedronGeometry args={[0.8, 0]} />
                        <meshStandardMaterial 
                            color="#ffd700"
                            roughness={0.1}
                            metalness={1.0}
                            emissive="#ffd700"
                            emissiveIntensity={1.5}
                        />
                    </mesh>
                </group>
            );
        };

        // Ê∏≤ÊüìÂ∫îÁî®
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
