<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Luxury Interactive Christmas Tree</title>
    <!-- ÊõøÊç¢‰∏∫Á®≥ÂÆöÁâàÊú¨ÁöÑCDNÔºåËß£ÂÜ≥ÂÖºÂÆπÊÄßÈóÆÈ¢ò -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18.3.1/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@react-three/fiber@8.14.5/dist/umd/index.min.js"></script>
    <script src="https://unpkg.com/@react-three/drei@9.80.1/dist/umd/index.min.js"></script>
    <script src="https://unpkg.com/@react-three/postprocessing@2.14.12/dist/umd/index.min.js"></script>
    <!-- MediaPipe ÂÆòÊñπCDNÔºàÁ®≥ÂÆöÁâàÔºâ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1646425220/camera_utils.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1646425220/drawing_utils.min.js"></script>
    
    <script>
        // Á¶ÅÁî®TailwindÁîü‰∫ßÁéØÂ¢ÉË≠¶Âëä
        tailwind.config = {
            corePlugins: {
                preflight: false,
            },
            theme: {
                extend: {
                    colors: {
                        emerald: {
                            deep: '#004d40',
                            lux: '#00695c'
                        },
                        gold: {
                            highlight: '#ffd700',
                            dark: '#b8860b'
                        }
                    },
                    fontFamily: {
                        luxury: ['Garamond', 'serif']
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .glow {
                filter: drop-shadow(0 0 8px theme('colors.gold.highlight'));
            }
            .tree-shadow {
                box-shadow: 0 0 20px theme('colors.emerald.deep');
            }
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at bottom, #0a1015 0%, #000 100%);
        }
        
        canvas {
            display: block;
        }
        
        #gesture-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: #ffd700;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #b8860b;
            font-family: 'Garamond', serif;
            z-index: 100;
            width: 220px;
        }
        
        #camera-feed {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border: 3px solid #ffd700;
            border-radius: 8px;
            overflow: hidden;
            z-index: 99;
            background: #000;
        }
        
        /* ÈöêËóèfaviconÊä•ÈîôÔºàÂèØÈÄâÔºâ */
        link[rel="icon"] {
            display: none;
        }
    </style>
    <!-- Ëß£ÂÜ≥favicon 404ÈóÆÈ¢ò -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='90' font-size='90'>üéÑ</text></svg>" type="image/svg+xml">
</head>
<body>
    <div id="root" class="w-full h-screen"></div>
    <div id="gesture-overlay">
        <h3 class="text-xl mb-2 font-luxury">üéÑ Luxury Xmas Tree</h3>
        <p class="text-sm">Open hand ‚Üí Chaos Mode</p>
        <p class="text-sm">Closed hand ‚Üí Tree Mode</p>
        <p class="text-sm">Move hand ‚Üí Adjust View</p>
        <div id="gesture-status" class="mt-4 text-gold-highlight">Status: Initializing...</div>
    </div>
    <div id="camera-feed"></div>

    <script>
        // ÂÖ®Â±ÄÂèòÈáèÂ£∞ÊòéÔºàËß£ÂÜ≥TSÂÖºÂÆπÈóÆÈ¢òÔºâ
        window.THREE = THREE;
        const { useState, useRef, useEffect, useMemo } = React;
        const { Canvas, useFrame, useThree } = ReactThreeFiber;
        const { OrbitControls, Environment, Points } = ReactThreeDrei;
        const { EffectComposer, Bloom, Noise, Vignette } = ReactThreePostprocessing;

        // Áä∂ÊÄÅÂ∏∏Èáè
        const TreeState = {
            CHAOS: 'CHAOS',
            FORMED: 'FORMED'
        };

        // Â∑•ÂÖ∑ÂáΩÊï∞ÔºöÁîüÊàêÈöèÊú∫ÂùêÊ†á
        const generateChaosPosition = () => {
            return new THREE.Vector3(
                (Math.random() - 0.5) * 40,
                (Math.random() - 0.5) * 30,
                (Math.random() - 0.5) * 40
            );
        };

        // Â∑•ÂÖ∑ÂáΩÊï∞ÔºöÁîüÊàêÊ†ëÂΩ¢ÁõÆÊ†áÂùêÊ†á
        const generateTargetPosition = (index, total) => {
            const layer = Math.floor(index / (total / 10));
            const radius = 8 - (layer * 0.8);
            const height = layer * 0.8;
            
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * radius;
            
            return new THREE.Vector3(
                Math.cos(angle) * r,
                height - 5,
                Math.sin(angle) * r
            );
        };

        // Âú£ËØûÊ†ëÊ†∏ÂøÉÁªÑ‰ª∂
        const ChristmasTree = ({ progress }) => {
            const foliageRef = useRef(null);
            const FOLIAGE_COUNT = 30000; // Èôç‰ΩéÁ≤íÂ≠êÊï∞ÊèêÂçáÊÄßËÉΩ
            
            // ÂàùÂßãÂåñÈíàÂè∂Á≤íÂ≠êÊï∞ÊçÆ
            const foliageData = useMemo(() => {
                const positions = [];
                const chaosPositions = [];
                const targetPositions = [];
                const colors = [];
                
                for (let i = 0; i < FOLIAGE_COUNT; i++) {
                    const chaosPos = generateChaosPosition();
                    const targetPos = generateTargetPosition(i, FOLIAGE_COUNT);
                    
                    chaosPositions.push(chaosPos.x, chaosPos.y, chaosPos.z);
                    targetPositions.push(targetPos.x, targetPos.y, targetPos.z);
                    
                    // Á•ñÊØçÁªøÊ∏êÂèò
                    const greenShade = new THREE.Color(0x00695c);
                    greenShade.offsetHSL(0, 0, Math.random() * 0.2 - 0.1);
                    colors.push(greenShade.r, greenShade.g, greenShade.b);
                    positions.push(targetPos.x, targetPos.y, targetPos.z);
                }
                
                return {
                    positions: new Float32Array(positions),
                    chaosPositions: new Float32Array(chaosPositions),
                    targetPositions: new Float32Array(targetPositions),
                    colors: new Float32Array(colors)
                };
            }, []);
            
            // ÂàùÂßãÂåñË£ÖÈ•∞Áâ©/ÊãçÁ´ãÂæóÊï∞ÊçÆ
            const ornamentData = useMemo(() => {
                const chaosPositions = [];
                const targetPositions = [];
                
                // ÊãçÁ´ãÂæó+Ë£ÖÈ•∞ÁêÉÊ∑∑Âêà
                for (let i = 0; i < 150; i++) {
                    const chaosPos = generateChaosPosition();
                    const layer = Math.floor(Math.random() * 8) + 1;
                    const radius = 6 - (layer * 0.6);
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * radius;
                    
                    const targetPos = new THREE.Vector3(
                        Math.cos(angle) * r,
                        layer * 0.8 - 3,
                        Math.sin(angle) * r
                    );
                    
                    chaosPositions.push(chaosPos.x, chaosPos.y, chaosPos.z);
                    targetPositions.push(targetPos.x, targetPos.y, targetPos.z);
                }
                
                return {
                    chaosPositions: new Float32Array(chaosPositions),
                    targetPositions: new Float32Array(targetPositions)
                };
            }, []);
            
            // Â∏ßÊõ¥Êñ∞ÔºöÊèíÂÄºÂä®Áîª
            useFrame(() => {
                if (foliageRef.current && foliageRef.current.geometry) {
                    const positions = foliageRef.current.geometry.attributes.position.array;
                    const chaos = foliageData.chaosPositions;
                    const target = foliageData.targetPositions;
                    
                    for (let i = 0; i < FOLIAGE_COUNT * 3; i += 3) {
                        positions[i] = THREE.MathUtils.lerp(target[i], chaos[i], progress);
                        positions[i + 1] = THREE.MathUtils.lerp(target[i + 1], chaos[i + 1], progress);
                        positions[i + 2] = THREE.MathUtils.lerp(target[i + 2], chaos[i + 2], progress);
                    }
                    
                    foliageRef.current.geometry.attributes.position.needsUpdate = true;
                }
            });
            
            // Ëá™ÂÆö‰πâÈíàÂè∂ÁùÄËâ≤Âô®ÊùêË¥®
            const foliageMaterial = useMemo(() => {
                return new THREE.ShaderMaterial({
                    uniforms: {
                        progress: { value: progress }
                    },
                    vertexShader: `
                        attribute vec3 color;
                        varying vec3 vColor;
                        uniform float progress;
                        
                        void main() {
                            vColor = color;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = 0.15 * (10.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        uniform float progress;
                        
                        void main() {
                            float distanceToCenter = length(gl_PointCoord - vec2(0.5));
                            if (distanceToCenter > 0.5) discard;
                            
                            gl_FragColor = vec4(vColor * (1.0 - progress * 0.5), 1.0);
                            gl_FragColor.rgb += vec3(0.1, 0.1, 0.0) * (1.0 - distanceToCenter * 2.0);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
            }, [progress]);
            
            // ÂàõÂª∫ÈíàÂè∂Âá†‰Ωï‰Ωì
            const foliageGeometry = useMemo(() => {
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(foliageData.positions, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(foliageData.colors, 3));
                return geo;
            }, [foliageData]);
            
            return (
                <group>
                    {/* ÈíàÂè∂Á≤íÂ≠êÁ≥ªÁªü */}
                    <Points 
                        ref={foliageRef}
                        geometry={foliageGeometry}
                        material={foliageMaterial}
                    />
                    
                    {/* Ê†ëÂπ≤ */}
                    <mesh position={[0, -5, 0]}>
                        <cylinderGeometry args={[1, 1.5, 4, 16]} />
                        <meshStandardMaterial 
                            color="#8B4513"
                            roughness={0.8}
                            metalness={0.2}
                        />
                    </mesh>
                    
                    {/* ÊãçÁ´ãÂæóË£ÖÈ•∞ */}
                    {Array.from({ length: 20 }).map((_, i) => {
                        const chaosPos = new THREE.Vector3(
                            ornamentData.chaosPositions[i * 3],
                            ornamentData.chaosPositions[i * 3 + 1],
                            ornamentData.chaosPositions[i * 3 + 2]
                        );
                        const targetPos = new THREE.Vector3(
                            ornamentData.targetPositions[i * 3],
                            ornamentData.targetPositions[i * 3 + 1],
                            ornamentData.targetPositions[i * 3 + 2]
                        );
                        
                        const pos = new THREE.Vector3().lerpVectors(targetPos, chaosPos, progress);
                        
                        return (
                            <mesh 
                                key={`polaroid-${i}`}
                                position={[pos.x, pos.y, pos.z]}
                                rotation={[0, Math.random() * Math.PI * 2, Math.random() * 0.2]}
                            >
                                <boxGeometry args={[0.8, 1, 0.1]} />
                                <meshStandardMaterial 
                                    color="#ffffff"
                                    roughness={0.9}
                                    metalness={0.1}
                                />
                                {/* ÁÖßÁâáÂÜÖÂÆπÔºàÈáëËâ≤/Á•ñÊØçÁªøÊ∏êÂèòÔºâ */}
                                <mesh position={[0, 0, 0.06]}>
                                    <planeGeometry args={[0.6, 0.6]} />
                                    <meshBasicMaterial 
                                        color={Math.random() > 0.5 ? 0xffd700 : 0x00695c}
                                        transparent
                                        opacity={0.9}
                                    />
                                </mesh>
                            </mesh>
                        );
                    })}
                    
                    {/* ÈáëËâ≤Ë£ÖÈ•∞ÁêÉ */}
                    {Array.from({ length: 80 }).map((_, i) => {
                        const chaosPos = new THREE.Vector3(
                            ornamentData.chaosPositions[(i + 20) * 3],
                            ornamentData.chaosPositions[(i + 20) * 3 + 1],
                            ornamentData.chaosPositions[(i + 20) * 3 + 2]
                        );
                        const targetPos = new THREE.Vector3(
                            ornamentData.targetPositions[(i + 20) * 3],
                            ornamentData.targetPositions[(i + 20) * 3 + 1],
                            ornamentData.targetPositions[(i + 20) * 3 + 2]
                        );
                        
                        const pos = new THREE.Vector3().lerpVectors(targetPos, chaosPos, progress);
                        
                        return (
                            <mesh 
                                key={`ornament-${i}`}
                                position={[pos.x, pos.y, pos.z]}
                                castShadow
                                receiveShadow
                            >
                                <sphereGeometry args={[0.2 + Math.random() * 0.3, 16, 16]} />
                                <meshStandardMaterial 
                                    color={Math.random() > 0.5 ? 0xffd700 : 0xb8860b}
                                    roughness={0.1}
                                    metalness={0.9}
                                />
                            </mesh>
                        );
                    })}
                    
                    {/* ÈáëËâ≤ÁÅØÂÖâ */}
                    {Array.from({ length: 150 }).map((_, i) => {
                        const chaosPos = new THREE.Vector3(
                            ornamentData.chaosPositions[(i + 100) * 3],
                            ornamentData.chaosPositions[(i + 100) * 3 + 1],
                            ornamentData.chaosPositions[(i + 100) * 3 + 2]
                        );
                        const targetPos = new THREE.Vector3(
                            ornamentData.targetPositions[(i + 100) * 3],
                            ornamentData.targetPositions[(i + 100) * 3 + 1],
                            ornamentData.targetPositions[(i + 100) * 3 + 2]
                        );
                        
                        const pos = new THREE.Vector3().lerpVectors(targetPos, chaosPos, progress);
                        
                        return (
                            <pointLight 
                                key={`light-${i}`}
                                position={[pos.x, pos.y, pos.z]}
                                color="#ffd700"
                                intensity={0.5}
                                distance={2}
                                decay={2}
                            />
                        );
                    })}
                    
                    {/* Ê†ëÈ°∂Êòü */}
                    <mesh 
                        position={[0, 3, 0]}
                        scale={1 - progress * 0.8}
                    >
                        <octahedronGeometry args={[0.8, 0]} />
                        <meshStandardMaterial 
                            color="#ffd700"
                            roughness={0.1}
                            metalness={1.0}
                            emissive="#ffd700"
                            emissiveIntensity={1.5}
                        />
                    </mesh>
                </group>
            );
        };

        // ‰∏ªÂ∫îÁî®ÁªÑ‰ª∂
        const App = () => {
            const [treeState, setTreeState] = useState(TreeState.FORMED);
            const [progress, setProgress] = useState(0);
            const [handPosition, setHandPosition] = useState({ x: 0, y: 0 });
            const cameraRef = useRef(null);
            const { camera } = useThree();
            
            // ÂàùÂßãÂåñÊëÑÂÉèÊú∫
            useEffect(() => {
                camera.position.set(0, 4, 20);
                cameraRef.current = camera;
                // ÊèêÁ§∫ÂàùÂßãÂåñÂÆåÊàê
                document.getElementById('gesture-status').textContent = 'Status: Ready (Waiting for hand)';
            }, [camera]);

            // ÊâãÂäøËØÜÂà´Ê†∏ÂøÉÈÄªËæë
            useEffect(() => {
                const videoElement = document.createElement('video');
                const cameraFeed = document.getElementById('camera-feed');
                cameraFeed.innerHTML = '';
                cameraFeed.appendChild(videoElement);
                
                // ÂàùÂßãÂåñMediaPipe Hands
                const hands = new window.mediapipe.hands.Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
                });

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 0, // Èôç‰ΩéÂ§çÊùÇÂ∫¶ÊèêÂçáÊÄßËÉΩ
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.7
                });

                // ÊâãÂäøËØÜÂà´ÁªìÊûúÂ§ÑÁêÜ
                hands.onResults((results) => {
                    const statusElement = document.getElementById('gesture-status');
                    
                    if (results.multiHandLandmarks && results.multiHandedness) {
                        const hand = results.multiHandLandmarks[0];
                        
                        // ËÆ°ÁÆóÊâãÊéå‰∏≠ÂøÉÂíåÊâãÊåáÂº†ÂºÄÂ∫¶
                        const thumbTip = hand[4];
                        const indexTip = hand[8];
                        const middleTip = hand[12];
                        const ringTip = hand[16];
                        const pinkyTip = hand[20];
                        const palm = hand[0];
                        
                        // ÊâãÊéå‰∏≠ÂøÉÂùêÊ†á
                        const palmX = (thumbTip.x + indexTip.x + middleTip.x + ringTip.x + pinkyTip.x) / 5;
                        const palmY = (thumbTip.y + indexTip.y + middleTip.y + ringTip.y + pinkyTip.y) / 5;
                        
                        // Êõ¥Êñ∞ÊâãÈÉ®‰ΩçÁΩÆÔºàÁî®‰∫éËßÜËßíÊéßÂà∂Ôºâ
                        setHandPosition({
                            x: (palmX - 0.5) * -10,
                            y: (palmY - 0.5) * 10
                        });
                        
                        // ËÆ°ÁÆóÊâãÊåáÂº†ÂºÄÁ®ãÂ∫¶
                        const calculateDistance = (point1, point2) => {
                            return Math.hypot(point1.x - point2.x, point1.y - point2.y);
                        };
                        
                        const thumbDistance = calculateDistance(thumbTip, palm);
                        const indexDistance = calculateDistance(indexTip, palm);
                        const middleDistance = calculateDistance(middleTip, palm);
                        const ringDistance = calculateDistance(ringTip, palm);
                        const pinkyDistance = calculateDistance(pinkyTip, palm);
                        
                        const avgDistance = (thumbDistance + indexDistance + middleDistance + ringDistance + pinkyDistance) / 5;
                        
                        // Êõ¥Êñ∞Áä∂ÊÄÅ
                        if (avgDistance > 0.15) {
                            setTreeState(TreeState.CHAOS);
                            setProgress(prev => Math.min(1, prev + 0.02));
                            statusElement.textContent = 'Status: Chaos Mode (Unleashed)';
                        } else {
                            setTreeState(TreeState.FORMED);
                            setProgress(prev => Math.max(0, prev - 0.02));
                            statusElement.textContent = 'Status: Formed Mode (Luxury Tree)';
                        }
                    } else {
                        statusElement.textContent = 'Status: No hand detected';
                    }
                });

                // ÂêØÂä®ÊëÑÂÉèÂ§¥
                const startCamera = async () => {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({
                            video: {
                                width: 200,
                                height: 150,
                                facingMode: 'user'
                            },
                            audio: false
                        });
                        videoElement.srcObject = stream;
                        videoElement.play();
                        
                        // ÁªëÂÆöÊëÑÂÉèÂ§¥Âà∞MediaPipe
                        videoElement.onloadedmetadata = () => {
                            videoElement.play();
                            hands.send({ image: videoElement });
                            
                            // Âæ™ÁéØÂ§ÑÁêÜÂ∏ß
                            const processFrame = async () => {
                                if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
                                    await hands.send({ image: videoElement });
                                }
                                requestAnimationFrame(processFrame);
                            };
                            processFrame();
                        };
                    } catch (err) {
                        console.error('Camera error:', err);
                        document.getElementById('gesture-status').textContent = 'Status: Camera access denied';
                    }
                };

                startCamera();

                // Ê∏ÖÁêÜÂáΩÊï∞
                return () => {
                    if (videoElement.srcObject) {
                        videoElement.srcObject.getTracks().forEach(track => track.stop());
                    }
                    hands.close();
                };
            }, []);

            // ËßÜËßíÊéßÂà∂
            useFrame(() => {
                if (cameraRef.current) {
                    // Âπ≥ÊªëË∑üÈöèÊâãÈÉ®ÁßªÂä®
                    cameraRef.current.position.x += (handPosition.x - cameraRef.current.position.x) * 0.05;
                    cameraRef.current.position.y += (4 + handPosition.y - cameraRef.current.position.y) * 0.05;
                    cameraRef.current.lookAt(0, 2, 0);
                }
            });

            return (
                <>
                    <color attach="background" args={['#000814']} />
                    <fog attach="fog" args={['#001a1a', 10, 50]} />
                    
                    {/* ÁéØÂ¢ÉÂÖâ */}
                    <Environment preset="lobby" />
                    <ambientLight intensity={0.3} color="#004d40" />
                    <directionalLight 
                        position={[10, 10, 5]} 
                        intensity={1.2} 
                        color="#ffd700"
                        castShadow
                    />
                    
                    {/* Âú£ËØûÊ†ë */}
                    <ChristmasTree progress={progress} />
                    
                    {/* ÂêéÊúüÂ§ÑÁêÜ */}
                    <EffectComposer>
                        <Bloom 
                            luminanceThreshold={0.8}
                            luminanceSmoothing={0.05}
                            intensity={1.2}
                            radius={0.5}
                        />
                        <Noise opacity={0.02} />
                        <Vignette eskil={false} offset={0.1} darkness={0.4} />
                    </EffectComposer>
                    
                    {/* Â§áÁî®ÊéßÂà∂Âô® */}
                    <OrbitControls 
                        enablePan={false}
                        enableZoom={true}
                        maxPolarAngle={Math.PI / 2}
                        minDistance={10}
                        maxDistance={30}
                    />
                </>
            );
        };

        // Ê∏≤ÊüìÂ∫îÁî®
        ReactDOM.render(
            <Canvas shadows dpr={[1, 2]}>
                <App />
            </Canvas>,
            document.getElementById('root')
        );
    </script>
</body>
</html>
